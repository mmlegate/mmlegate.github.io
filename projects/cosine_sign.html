<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial scale=1.0">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jacquard+12+Charted&family=Karla&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <link rel="stylesheet" href="projects.css">

    <script defer src="https://pyscript.net/alpha/pyscript.js"></script>

    <title>Cosine Sign Correlation</title>
</head>

<body>
    <!-- NAV BAR -->
    <nav>
        <div class="left">
            <a href="/">Madeline Legate</a>
        </div>
        <div class="right">
            <a href="http://github.com/mmlegate" target="_blank" rel="noopener no-referrer">
                <i class="fa-brands fa-square-github"></i>
                <span>Github</span>
            </a>

            <a href="http://linkedin.com/in/madeline-legate-8405801a6/" target="_blank" rel="noopener no-referrer">
                <i class="fa-brands fa-linkedin"></i>
                <span>Linkedin</span>
            </a>

            <a href="mailto:legate.madeline@gmail.com" >
                <i class="fa-solid fa-square-envelope"></i>
                <span>Email</span>
            </a>
        </div>
    </nav>

        <!-- INTRODUCTION -->
        <section class="intro-section">
            <div class="text"> <h2>Cosine Sign Correlation</h2>
                <p>I was able to do research at UW in the Washington eXperimental Mathematics Lab (WXML) under the expert guidance of Professor Stefan Steinerberger. We were concerned with the coupling and decoupling of cosine functions of a particular form: <b>cos(ax)</b>, where <b>a</b> is some natural number. We determined how to choose 3 cosine coefficients such that all three functions share the same sign the minimum amount of time. </p>
                <p>The applications of this research lies primarily in quantum mechanics, as cosine functions are the building block of virtually all possible wavefunctions. The Hermite polynomials are the eigenfunctions of the harmonic oscillator, which can be used to model any potential well in a quantum system.</p> 
                <p><b>We are essentially proving that entanglement is an emergent property of the mathematical structures that describe quantum objects.</b></p>
                <div class="links">
                    <a href="#tools">
                        <i class="fa-solid fa-tools"></i>
                        <span>Tools</span>
                    </a>
    
                    <a href="#result">
                        <i class="fa-solid fa-gift"></i>
                        <span>Result</span>
                    </a>
    
                    <a href="#code">
                        <i class="fa-solid fa-code"></i>
                        <span>Code</span>
                    </a>
                </div>
            </div> 
            <div class="headshot">
                <img src="/../images/torus_variations3.webp">
            </div>
        </section>
    
        <!-- TOOLS -->
        <section id="tools" class="tools-section"> <h2>Tools</h2>
            <div class="tab-wrap">
    
                <!-- active tab on page load gets checked attribute -->
                <input type="radio" id="tab1" name="tabGroup1" class="tab" checked>
                <label for="tab1"><img src="/../images/python_logo.webp" alt="Python logo"></label>
            
                <input type="radio" id="tab2" name="tabGroup1" class="tab">
                <label for="tab2"><img src="/../images/colab_logo.webp" alt="Google Colab logo"></label>
            
                <input type="radio" id="tab3" name="tabGroup1" class="tab">
                <label for="tab3"><img class="latex" src="/../images/latex_logo.webp" alt="Latex logo"></label>
            
                <div class="tab__content">
                    <h4>Python</h4>
                    <i>Python is a versatile programming language, widely used in web development, data science, AI, and automation, supported by a rich ecosystem of libraries and frameworks.</i>
                    <br>
                    <br>
                    <ul>
                        <li>While the formal proof is done on paper, and most mathematical discussion was verbal, Python was pivotal in the completion of our research.</li>
                        <li>Since <b>a</b>, the coefficient of a cosine function, can be an infinite amount of numbers, we were tasked of reducing <b>a</b>'s possible values by simply using the tricks of Fourier Analysis and other mathematics. Once we have a finite amount of coefficients, we can run those combinations in a computer to see which 3 coefficients share the sign the least amount of time.</li>
                        <li>We also mathematically modeled our research for a better understanding of the topological interpretation of cosine functions. This involved visual representations of cosine functions, plotted on a torus.</li>
                    </ul>
                </div>
            
                <div class="tab__content">
                    <h4>Google Colab</h4>
                    <i>Google Colab is a cloud-based Jupyter notebook environment that allows you to write, execute, and share code, while also using free GPU and TPU resources for machine learning and data analysis tasks.</i>
                    <br>
                    <br>
                    <ul>
                        <li>Since we used Python to compute the decoupling of various cosine functions, we found that Colab was the best way to host our code, and effectively . . . collaborate. </li>
                        <li>For a full tutorial on the research done in WXML, please see the notebook provided in my Github which is linked below.</li>
                        <li>Colab was most handy for displaying the visualizations of cosine functions in real-time, so we could topologically understand how two coefficients decoupled the cosine functions.</li>
                    </ul>
                </div>
            
                <div class="tab__content">
                    <h4>LaTex</h4>
                    <i>LaTeX is a powerful typesetting system widely used for creating professionally formatted documents, particularly in academic and technical fields, known for its ability to handle complex layouts, mathematical equations, and references with ease.</i>
                    <br>
                    <br>
                    <ul>
                        <li>LaTex is the best friend of most mathematicians when it comes to formatting documents, and as UW's Math department encourages the use of LaTex for formatting homework, we were all very familiar with its functionalities.</li>
                        <li>We constructed our formal proof via LaTex which is now published in the Journal of Fourier Analysis and Applications, arXiv, and a few others.</li>
                        <li>Using LaTex, we formatted the presentation of our findings. We presented our research to fellow WXML members and other Math faculty at the UW.</li>
                    </ul>
                </div>
            
              </div>
        </section>
    
        <!-- RESULT -->
        <section id="result" class="result-section"> <h2>Area of Inquiry</h2>
            <div class="inquiry">
                Consider two cosine functions:
                <br><b>
                <div>f(x) = cos(ax)
                <br>
                g(x) = cox(bx)</div>
                <br></b>
                Where <b>a</b> and <b>b</b> are arbitrary integers. If we plot these two functions, we can see their coupling, or in this case how much and how long they are both positive/negative. That is our primary concern, for which values of <b>a</b> and <b>b</b> can we minimize the amount of time that these two functions share the same sign.
                <br>
                <br>
                Note that sinusoidal functions are infinite, and we expect two infinite functions to share the same sign about 50% of the time. Would you be surprised if I told you that this is not always the case?
                <br>
                <br>
                For example, let <b>a=1</b> and <b>b=3</b>:
                <br>
                <br>
                <div class="comparison">
                <img src="/../images/cosine_plot_plane.webp" class="wide">
                <img src="/../images/cosine_plot_torus.webp" class="tall">
                </div>
                We can express infinite cosine functions in a finite manner by using the topological map of the torus. Moreover, we can further simplify this visualization by 'unwrapping' the torus like so and plotting the ratio of cosine angles.
                <br>
                <div class="comparison">
                <img src="/../images/torus_to_rectangle.gif" class="wide">
                <img src="/../images/ratio_plot_plane.webp" class="tall">
                </div>
                Try it yourself!
                <label for="input1">Enter first number:</label>
    <input type="number" id="input1" value="1">
    
    <label for="input2">Enter second number:</label>
    <input type="number" id="input2" value="3">
    
    <button id="generateButton">Generate Graph</button>

    <div id="output">
        <py-script output="graph"></py-script>
    </div>

    <py-script>
import matplotlib.pyplot as plt
import numpy as np

def find_sign_change(coeff=1):
  """
  Finds the x-values corresponding to sign changes in a cosine function

  Parameters:
  coeff: Coefficient of cosine function

  Returns:
  important_x: Array of x-values corresponding to sign changes
  """
  unit = 1 / (2*coeff)
  important_x = [0]
  for i in range(0, 2*coeff):
    important_x.append(unit + 2*unit*i)
  important_x.append(2)
  return np.array(important_x)

def get_patches(coeffs=[1]):
  """
  Finds the coordinates and dimensions of regions where two cosine functions share the same sign

  Parameters:
  coeffs: Coefficients of two cosine functions

  Returns:
  patches: List of matplotlib patches
  """
  patches = []

  important_min_x = find_sign_change(min(coeffs))
  important_max_x = find_sign_change(max(coeffs))

  # Add patches where two cosine functions are both positive
  for i in range(0, len(important_min_x), 2):
    for j in range(0, len(important_max_x), 2):
      vert = [important_min_x[i], important_max_x[j]]
      width = important_min_x[i+1] - important_min_x[i]
      height = important_max_x[j+1] - important_max_x[j]
      rect = mpatches.Rectangle(vert, width, height, alpha=0.1, facecolor="blue")
      patches.append(rect)

  # Add patches where two cosine functions are both negative
  for i in range(1, len(important_min_x)-1, 2):
    for j in range(1, len(important_max_x)-1, 2):
      vert = [important_min_x[i], important_max_x[j]]
      width = important_min_x[i+1] - important_min_x[i]
      height = important_max_x[j+1] - important_max_x[j]
      rect = mpatches.Rectangle(vert, width, height, alpha=0.1, facecolor="blue")
      patches.append(rect)

  return patches

# Get the input values
num1 = int(Element("input1").element.value)
num2 = int(Element("input2").element.value)
coeffs = [num1, num2]

# Calculate slope from coefficients
slope = max(coeffs)/min(coeffs)

# Define original set of linear lines
# Original set should contain only one line
N = 1000
x_0 = np.array([np.linspace(0, 2, N)])
y_0 = np.array([slope * np.linspace(0, 2, N)])

def yoverload(x_line, y_line, max_length):
    """
    Plots ratio of angles from two cosine functions on a torus in the y-direction

    Parameters:
    x_line, y_line: Set of cartesian coordinates of original linear function
    max_length: Maximum number of lines to plot, note some pairings of cosine functions may produce more than max_length lines

    Returns:
    x_line, y_line: Cartesian coordinates of plotted linear function on torus
    """
    # Initial check to see if number of lines in y_line is over max_length
    if len(y_line) > max_length:
      return x_line, y_line

    # We are concerned with the last element of the set y_line
    y = y_line[-1]

    # We need index where y first passes 2, as this is where y re-enters from the bottom of torus
    index = len(y)
    print(index)
    for i in range(len(y)):
      if y[i] > 2:
        index = i
        break

    # Loop through y-values and subtract 2 until all values are less than or equal to 2
    for i in range(math.ceil(N/index)):
      # Split y on index so that last element in y contains only numbers greater than 2
      y = np.split(y, [index])

      # If y[-1] contains elements, we parse through and subtract 2
      # Then, we update the index
      if len(y[-1]) > 0:
        for j in range(len(y[-1])):
          y[-1][j] = y[-1][j] - 2
        for j in range(len(y[-1])):
          if y[-1][-1] <= 2:
            index += len(y[-1])
            break
          if y[-1][j] > 2:
            index += j
            break
        y = np.concatenate(y)

      # If y[-1] is empty, we break out of the loop
      # This means all y-values are less than 2
      else:
        break

    y = np.concatenate(y)

    # Replace last element of y_line with our new array of values in range [0, 2]
    y_line[-1] = y

    # If last element of new array is less than two, line re-enters on other side of torus
    # We account for re-entry on x-direction with xoverload() function
    if y[-1] < 2:
      return xoverload(x_line, y_line)

    # Return x_line and y_line with values adjusted for torus geometry
    return x_line, y_line

def xoverload(x_line, y_line):
    """
    Plots ratio of angles from two cosine functions on a torus in the x-direction

    Parameters:
    x_line, y_line: Set of cartesian coordinates of original linear function

    Returns:
    yoverload(x, y): Cartesian coordinates of plotted linear function on torus in x-direction, y-direction to be adjusted by yoverload()
    """
    # Point of re-entry on x-axis is (0, right_endpoint)
    right_endpoint =y_line[-1][-1]

    # Adjust y-values with intercept
    y_appendage = slope * np.linspace(0, 2, N) + right_endpoint

    # Append both x_line and y_line with new lines, now adjusted in x-direction
    x = np.append(x_line, [np.linspace(0, 2, N)], axis=0)
    y = np.append(y_line, [y_appendage], axis=0)

    # Pass to yoverload to adjust y-values so that they are in range [0, 2]
    return yoverload(x, y)

x, y = yoverload(x_0, y_0, 20)
patches = get_patches()

def generate_graph():
    plt.figure()
    for i in range(len(y)):
      plt.scatter(x[i], y[i], s=1, color='blue')
    for patch in patches:
      plt.gca().add_patch(patch)
    #plt.xlim(0, 2)
    #plt.ylim(0, 2)
    plt.xlabel('Radians')
    plt.ylabel('Radians')
    plt.title('Ratio of Cosine Angles on Torus')
    plt.grid()
    plt.show()

# Bind the button click event to the generate_graph function
Element("generateButton").element.onclick = generate_graph
    </py-script>
            </div>
        </section>
    
        <!-- CODE -->
        <section id="code" class="code-section">
            <div class="text"> <h2> Source Code:</h2>
                <a href="https://github.com/mmlegate/mmlegate.github.io/tree/main/projects"><pre><code class="python">for n in range(15):
    if a[-1][-1] != 2:
        #v = a[-1][-1]
        for j in range(1,31):
            a.append([])
            ax.append([])
            for k in range(A):
                #if slope*x[k] + a[-1-j][-1]<= 2*j
                if slope*x[k] + a[-1-j][-1]<= 2*j and slope*x[k] + a[-1-j][-1]>2*(j-1):</code></pre></a>
    
            </div> 
            <div class="headshot">
                <img src="/../images/torus background.webp">
            </div>
        </section>
</body>